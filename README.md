# 408Note
考研计算机408复习笔记—计算机组成原理

一、数据的表示和运算

1.定点数的编码表示

(1).原码

    最高位为符号位，0为正，1为负。
  
    例如：(机器字长为8位) x1=+0.1101,[x1]原=0.1101000;
    x2=-0.1101,[x2]原=1.1101000;
    x3=+1110,[x3]原=0,0001110;x2=-1110,[x2]原=1,0001110。

  原码的真值0有两种表达方式，分别是[+0原]和[-0原]。
  
   若字长为n+1，则原码小数的表示范围为$-(1-2^{-n})\leq x\leq 1-2^{-n}$。
   原码整数的表示范围为$-(2^{n}-1)\leq x\leq 2^{n}-1$。
  
  原码的缺点：符号位不能参与运算。

(2).补码

  原码加减运算比较复杂，补码的加减运算统一采用加法操作实现。
  
  补码的真值0只有一种表达方式。
  
  正数的原码、反码、补码表示不变。
  
  负数的原码和反码互化：符号位不变，数值位取反。
  
  负数的反码转化为补码：末位+1。
  
  原码和补码互化快速方法：从右往左找到第一个“1”，该位左边所有数值为全部按位取反，符号位保持不变，该位及其右边的位不变。

  计算机硬件做补码的加法：从最低为开始，按位相加(符号位参与运算)，并向更高位进位。
  
  计算机硬件做补码的减法运算：[A]补-[B]补 => [A]补+[-B]补。(补码求其负值：全部位按位取反，末位+1）。

    若字长为n+1，则补码小数的表示范围为$-1\leq x\leq 1-2^{-n}$(比原码多表示-1)。
    补码整数的表示范围为$-2^{n}\leq x\leq 2^{n}-1$(比原码多表示)。
  
(3).移码

  在补码的基础上，符号位取反。[注]：移码只能用于表示整数。
  
    移码的表示范围：$-2^{n}\leq x\leq 2^{n}-1$。
  
  
  
二.运算方法和运算电路

  1.一位全加器
  
   全加器(FA)是最基本的加法单元，有加数Ai、加数Bi和低位传来的进位Ci-1共三个输入，有本位和Si与向高位的进位Ci共两个输出。
    
   全加器的逻辑表达式：
    
   和表达式：$Si=Ai\oplus Bi\oplus Ci-1$
   (Ai，Bi，Ci中有奇数个1时，Si=1；否则Si=0)。
    
   进位表达式：
   
   $Ci=AiBi+\left (  Ai\oplus Bi\right )Ci-1$
   
 2.串行进位加法器
   
   把n个全加器相连得到n位加法器。最长运算时间主要是由进位信号的传递时间决定的，位数越多延迟时间就越长。
   
 3.并行进位加法器
 
   令Gi=AiBi，$Pi=Ai\oplus Bi$。
   
          Ci=Gi+PiPi-1(Gi=1或PiCi-1=1时，Ci=1)
   
   C1=G1+P1C0
   
   C2=G2+P2C1=G2+P2G1+P2P1C0
   
   C3=G3+P3C2=G3+P3G2+P3P2G1+P3P2P1C0
   
   一般四个一组实现并行计算进位，该逻辑表达式的电路称为先行进位(也称超前进位)部件，简称CLA部件。
   
   这种进位方式是快速的，与位数无关。但随着加法器位数的增加，Ci的逻辑表达式会变得越来越长，这会使电路结构变得很复杂。
   
 4.补码加减运算电路
 
  计算机有符号整数与无符号整数进行加减运算使用的是相同的补码加减运算部件，但判断溢出时有符号整数与无符号整数完全不同。
  
  标志位：
  
  OF(Overflow Flag)溢出标志：仅在有符号数的加减运算中有意义，溢出时为0，否则置1。
   
   硬件的计算方法：$OF=最高位产生的进位\oplus 次高位产生的进位$
   
  SF(Sign Flag)符号标志：仅在有符号数的加减运算中有意义，运算结果为正置为0，为负置为1
  
   硬件的计算方法：SF=最高位的本位和
   
  ZF(Zero Flag)零标志：运算结果为0时置为1，否则为0
  
  CF(Carry Flag)进位/借位标志：只对无符号数的加减法有意义，对有符号数的加减法无意义。进位/借位时置1，否则为0
  
   硬件的计算方法：$CF=最高位产生的进位\oplus sub$
   ，sub=1时表示减法，sub=0时表示加法。

 5.移位运算
 
  算数移位：
  
    原码的算数移位——符号位保持不变，仅对数值为进行移位
    
    右移：高位补0，低位舍弃。若舍弃的位=0，则相当于÷2；若舍弃的位≠0，则会丢失精度。
    
    左移：低位补0，高位舍弃。若舍弃的位=0，则相当于×2；若舍弃的为≠0，则会出现严重误差。
    
  逻辑移位：
  
    逻辑右移：高位补0，低位舍弃。
    
    逻辑左移：低位补0，高位舍弃。
    
  循环移位
  
6.定点数的乘除运算

  原码一位乘法：
    
    符号位通过异或确定，数值位由被乘数和乘数的绝对值进行n轮加法、移位。
    
    MQ中最低位为1时，(ACC)+[|x|]原；MQ中最低位为0时，(ACC)+0；
    
    每次移位都是“逻辑右移”，乘数的符号位不参与运算。
    
  补码一位乘法(Booth算法):
    
    符号位、数值位都由被乘数和乘数进行n轮加法、移位，最后再多进行一次加法。
    
    辅助位-MQ中最低位=1时，ACC+[x]补；
    
    辅助位-MQ中最低为=0时，(ACC)+0;
    
    辅助位-MQ中最低为=-1时，(ACC)+[-x]补；
    
    每次移位是“补码的算数右移”，乘数的符号位参与运算。
    
  原码除法(不恢复余数法)：
  
    先用被除数减去除数(|X|-|Y|=|X|+(-|Y|)=|X|+[-|Y|补])，当余数为正时，商上1，余数和商左移一位，再减去除数；
    
    当余数为负时，商上0，余数和商左移一位，再加上除数。
    
    当第n+1步余数为负时，需加上|Y|得到第n+1步正确的余数(余数与被除数同号)。
    
    商符和商值是分开进行的，$Qs=Xs\oplus Ys$。
    
  补码除法(加减交替法)：
  
    1.符号位参与运算，除数与被除数均由补码表示，商和余数也用补码表示
    
    2.若被除数与除数同号，则被除数减去除数；若被除数与除数异号，则被除数加上除数
    
    3.若余数与除数同号，则商上1，余数左移一位减去除数；若余数与除数异号，则商上0，余数左移一位加上除数
    
    4.重复执行第3步操作n此
    
    5.若对商的精度没有特殊要求，则一般采用“末位恒置1”法
    
7.强制类型转换

  无符号数与有符号数：
    
    不改变数据内容，改变解释方式
    
  长整数变短整数：
  
    高位截断，保留低位
    
  短整数变长整数：
  
    符号扩展
    
8.数据的存储和排列

  大小端模式(多字节数据在内存中一定是连续的几个字节)：
  
  大端模式(便于人类阅读)：
  
    先存入高位，后存低位
    
  小端模式(便于机器处理)：
  
    先存低位，后存高位
    
  边界对齐：
  
    每次访存只能读/写一个字。假设存储字长为32位，可按字节、半字和字寻址。对于机器字长为32位的计算机，数据以边界对齐方式存放，
    半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取的数据是字节、半字还是字，均可一次访存取出。所存储的数据不满足上述要求时，
    通过填充空白字节使其符合要求。这样虽然浪费了一些存储空间，但可提高指令和取数的速度。
    
9.浮点数

  浮点数的表示格式：
  
    通常，浮点数表示为：  N=(-1)^s×M×R^E
    
    式中，S取值0或1，用来决定浮点数的符号；M是一个二进制定点小数，称为尾数，一般用定点原码小数表示；E是一个二进制定点整数，称为阶码或指数，
    用移码表示。R是基数(隐含)，可以约定为2、4、16等。可见浮点数由数符、尾数和阶码三部分组成。
    
  浮点数的规格化：
  
    左规：当运算结果的尾数的最高数位不是有效位，需进行左规。左规时，尾数每左移一位、阶码减1，直至尾数变成规格化形式为止。
    
    右规：当运算结果尾数出现溢出(双符号位为01或10时)，需要进行右规。将尾数右移一位、阶码加1.需要右规时，只需进行一次。
    
10.IEEE754

  由浮点数确定真值(阶码不是全0也不是全1):
    
    1.根据“某浮点数”确定数符、阶码、尾数的分布
    2.确定尾数1.M(注意补充最高位隐含的1)
    3.确定阶码的真值=移码-偏置值(可将移码看作无符号数，用无符号数的值减去偏置值)
    4.(-1)^s×M×2^E-偏置值 
    
11.浮点数的加减运算

  浮点数加减运算步骤：
  
    1.对阶：阶数更小的向阶数大的对齐
    2.尾数加减
    3.规格化
    4.舍入
      1."0"舍"1"入法：右规时，被移出的的最高数值位为"0"时，则舍去；被移出的最高数值位为"1"时，则在尾数的末尾加1.这样可能会使尾数又有溢出，
        此时需要再做一次右规
      2.恒置"1"法：不论丢掉的最高数值位是"1"还是"0"，都使右移后的尾数末位恒置"1"
    5.判溢出(只有阶码的溢出才是真正的溢出，尾数的溢出未必导致整体溢出)
    
    
三.存储系统

1.存储器的分类

  1.存储器的层次化结构：
  
    高速缓冲存储器(Cache)
    主存储器
    辅存储器
    外存
    
  2.按存取方式分类：
  
    1).随机存储器(RAM)：读写任何一个存储单元，所需时间都相同
    2).只读存储器(ROM)：只能读，不能写
    3).顺序存取存储器(SAM)：读写一个存储单元所需时间取决于存储单元所在的物理位置
    4).直接存取存储器(DAM)：先直接选取信息所在区域，然后按顺序方式存取
    5).相联存储器(CAM)：可以按照内容检索到存储位置进行读写，"快表"就是一种相联存储器
    
  3.按信息的可保存性分类：
  
    断电后，存储信息消失的存储器——易失性存储器(RAM，主存，cache)
    断电后，存储信息依然保存的存储器——非易失性存储器(ROM,磁盘，光盘)
    
    信息读出后，原存储信息被破坏——破坏性读出(DRAM芯片，读出数据后要进行重写)
    信息读出后，原存储信息不被破坏——非破坏性读出(如SRAM芯片、磁盘、光盘)
    
2.存储器的性能指标

  1.存储容量：存储字长×字长(如1M×8位)
  
  2.单位成本：每位价格=总成本/总容量
  
  3.存储速度：数据传输率=数据的宽度/存储周期
  
3.存储芯片的地址分配和片选

  CPU要实现对存储单元的访问，首先要选择存储芯片，即进行片选；然后为选中的芯片依地址码选择相应的存储单元，以进行数据的存取，即进行字选
  
  片选信号的缠上分为线选法和译码片选法
  
  1.线选法：
  
    用除片内寻址外的高位地址线直接分别接至各个存储芯片的片选端，当某地址信息为"0"时，就选中与之对应的存储芯片。
    优点：不需要地址译码器，线路简单。
    缺点：地址控件不连续，选片的地址线必须分时为低电平，不能充分利用系统的存储器空间。
    
  2.译码片选法：
  
    用一片74LS138作为地址译码器，则A15A14A13=000时，选中的一片，A15A14A13=001时选中第二片
    
4.DRAM和SRAM

  DRAM用于主存，SRAM用于Cache
  
      类型特点                 SRAM(静态RAM)       DRAM(动态RAM)
      存储信息                  双稳态触发器             电容
      破坏性读出                     非                  是
      读出后需要重写？(再生)         不用                 需要
      运行速度                       快                  慢
      集成度                         低                  高
      发热量                         大                  小
      存储成本                       高                  低
      易失/非易失性存储器？   易失(断电后信息消失） 易失(断电后信息消)
      需要"刷新"？                  不需要               需要
      送行列地址                    同时送              分两次送
      
  DRAM电容上的电荷一般只能维持1-2ms，因此，每隔一定时间必须刷新，通常取2ms，称为刷新周期。常用的刷新方式(刷新由存储器独立完成，不需要CPU控制)：
      
        假设DRAM内部结构排列成128×128，读/写周期0.5us，2ms共2ms/0.5=4000个周期
    1.分散刷新：每次读写完都刷新一行——>系统的存取周期变为1us
    2.集中刷新：2ms内集中安排时间全部刷新——>存取周期还是0.5us，有一段专门时间用于刷新，无法访问存储器，称为访存"死区"
    3.异步刷新：2ms内每行刷新一次即可——>2ms内需要产生128次刷新请求，每个2ms/128=15.6us刷新一次，每15.6us内由0.5us的"死时间"
    
5.ROM
  
  MROM、PRMOM、EPROM、FLASH MEMORY(U盘、SD卡)、SSD固态硬盘
  
6.主存储器与CPU的连接
  
  主存容量的扩展：
  
  1.位扩展法：
  
    将多个存储芯片的地址端、片选端和读写控制端相应并联，数据段分别引出
    
  2.字扩展法：
  
    字扩展是指增加存储器中字的数量，而位数不变。字扩展将芯片的的地址线、数据线、读写控制线相应并联，而由片选信号来区分各芯片的地址范围
    
  3.字位同时扩展法：
  
    存储器往往需要同时扩充字和位。字位同时扩展是指既增加存储子的数量，有增加存储字长
    
7.多模块存储器

  1.多体并行存储器
  
    高位交叉编址的多体存储器：高位地址表示体号，地位地址为体内地址
    低位交叉编制的多体存储器：低位地址表示体号，高位地址为体内地址
    
  2.单体多字存储器
  
    每次只能同时取m个字，不能单独取其中某个字
    
8.外部存储器

  1.磁盘存储器
  
    存储区域：
      1.磁头数：即记录面数，表示硬盘共有多少个磁头，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头
      2.柱面数：表示每面盘片上有多少条磁道。在一个盘组中，不同记录面的相同变得号诸磁道构成一个圆柱面
      3.扇区数：表示每条磁道上有多少个扇区
      
    硬盘存储器：
      由磁盘驱动器、磁盘控制器和盘片组成
      
  2.磁盘的性能指标
  
    1.磁盘的容量
    2.记录密度：道密度、位密度、面密度
    3.平均存取时间：
      平均存取时间=寻道时间(磁头移动到目的磁道)+旋转延迟时间(磁头定位到所在扇区)+传输时间(传输数据所花费的时间)
    4.数据传输率：
      假设磁盘转速为r(转/秒),每条磁道容量为N个字节，则数据传输率为Dr=rN
      
  3.磁盘地址
    
    驱动器号 柱面(磁道)号 盘面号 扇区号
    
  4.磁盘阵列
  
    RAID0：无冗余和无校验的磁盘阵列(没有容错能力)
    RAID1：镜像磁盘阵列(有容错能力，两个磁盘当一个磁盘使用)
    RAID2：采用纠错的海明码的磁盘阵列
    RAID3：位交叉奇偶校验的磁盘阵列
    RAID4：块交叉奇偶校验的磁盘阵列
    RAID5：无独立校验的奇偶校验磁盘阵列
    
  5.固态硬盘
  
    1.原理：基于闪存技术Flash Memory ，属于电可擦除ROM，即EEPROM
    
    2.组成：
    
      闪存翻译层：负责翻译逻辑块号，找到对应页
      存储介质：多个闪存芯片，每个芯片包含多个块，每个块包含多个页
      
    3.读写性能特性：
    
      以页为单位读/写
      以块为单位"擦除"，擦干净的块，其中的每页都可写一次，读无限次
      支持随机访问，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址
      读快、写慢。要写的页如果有数据，需要将块内其他页全部复制到一个新的(擦除过的)快中，再写入新的页
      
    4.与机械硬盘相比的特点
    
      SSD读写速度快，随机访问性能高，用电路控制访问位置；机械硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟
      SSD安静无噪音、耐摔抗震、能耗低、造价更贵
      SSD的一个"块"被擦除的过多可能会坏掉，而机械硬盘的扇区不会因为写的过多而坏掉
      
    5.磨损均衡技术
    
      思想：将"擦除"平均分布在各个块上，以提升使用寿命
      动态磨损均衡：写入数据时，优先选择累计擦除次数少的新闪存块
      静态磨损均衡：SSD监测自动进行数据分配、迁移，让老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的读写任务
      
9.Cache

  1.性能分析
  
    命中率H：CPU欲访问的信息已在Cache中的比率
    
    不命中率M=1-H
    
    Cache——主存平均访问时间t为
    
    tc为访问cache时间，tm为访问主存所需时间
    
      t=Htc+(1-H)(tc+tm)  (先访问cache，再访问主存)
      t=Htc+(1-H)tmH  (同时访问cache和主存)
      
  2.Cache和主存的映射方式
  
    1.全相联映射
    
      主存块可以放在Cache的任意位置
      
    2.直接映射方式
    
      每个主存块只能放在一个特定的位置：Cache块号=主存块号%Cache总块数
      
    3.组相联映射
    
      Cache分为若干组，每个主存块可放在特定分组的任意位置
      组号=主存块数%分组数
      
  3.Cache中主存块的替换算法
  
    1.随机算法(RAND)
    
    2.先进先出算法(FIFO)
    
      替换最先被调入的Cache块
      抖动现象：频繁的换入换出现象
      
    3.近期最少使用算法(LRU)
    
      为每一个Cache块设置一个计数器，记录每个Cache块已经有多久没被访问。当Cache满后，替换计数器最大的
      有可能发生抖动现象
      
    4.最不经常使用算法(LFU)
    
      为每一个Cache块设置一个计数器，记录每个Cache块被访问过多少次。当Cache满后，替换计数器最小的。若有多个计数器最小的行，
      可按行号递增或FIFO策略进行选择
      
      实际运行效率不如LRU
      
  4.Cache写策略
  
    1.写命中
    
      写回法——当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存
      全写法——当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲
      
    2.写不命中
    
      写分配法——当CPU对Cache写不命中时，把主存中的数据调入Cache中，在Cache中修改
      非写分配法——当CPU对Cache写不命中时，不调入Cache
  
  
  
  
四.指令系统

  一条指令通常包括操作码字段和地址码字段两部分
  
  1.零地址指令
      
    零地址：     OP
      
      1.不需要操作数，如空操作、停机、关中断等指令
      2.堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果押回栈顶
      
  2.一地址指令
  
    一地址：   OP  A1
      
      1.只需要单操作数，如加1、减1、取反、取补
        指令含义：OP(A1)——>A1，完成一条指令需要三次访存：取指——>读A1——>写A1
        
      2.需要两个操作数，但其中一个操作数隐含在某个寄存器(如隐含在ACC中)
        指令含义：(ACC)OP(A1)——>ACC，完成一次指令需要两次访存：取指——>读A1
        
  3.二地址指令
  
    二地址：   OP A1(目的操作数) A2(源操作数)
    
  4.三地址指令
  
    三地址：   OP A1 A2 A3(结果)
    
  5.四地址指令
  
    四地址：   OP A1 A2 A3(结果) A4(下址)
    
  
  按指令长度分类
  
    指令字长：一条指令的总长度(可能会变)
    
    定长指令字结构：指令系统中所有指令的长度相等
    
    变长指令字结构：指令系统中各种指令的长度不等
    
    定长操作码：指令系统中所有指令的操作码长度相同
    
      n位——>2^n条指令
    
    可变长操作码：指令系统中指令的操作码长度可变
    
  按操作类型分类
  
    1.数据传送
    
    2.算术逻辑操作
    
    3.移位操作
    
    4.转移操作
    
    5.输入输出操作
    
  定长指令字结构+可变长操作码 ——> 扩展操作码指令格式
  
  注意：1.不允许短码是长码的前缀
       2.各指令的操作码一定不能重复
       
       设地址长度为n，上一层留出m种状态，下一层可扩展出m×2^n种状态
       
       
   指令寻址和数据寻址
   
    1.指令寻址
    
      1.顺序寻址
      
      2.跳跃寻址
      
    2.数据寻址(确定本条指令的地址码指明的真实地址)
    
      1.直接寻址
      
        指令字中的形式地址A就是操作数的真实地址EA，即EA=A
        
      2.间接寻址
      
        形式地址A指向操作数有效地址所在的存储单元的地址，即EA=(A)
        
      3.寄存器寻址
      
        直接给出操作数所在的寄存器编号，即EA=Ri，其操作数在由Ri所指的寄存器内
        
      4.寄存器间接寻址
      
        寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=(Ri)
        
      5.隐含寻址
      
        在指令中隐含着操作数的地址
        
      6.立即寻址
      
        形式地址A本身就是操作数本身，又称立即数，一般采用补码形式。
          #表示立即寻址
          
      7.基址寻址
      
        在CPU中基址寄存器(BR)的内容加上指令格式中的形式地址A，EA=(BR)+A
        
      8.变址寻址
      
        形式地址A与变址寄存器IX的内容之和，EA=(IX)+A
        
        注：变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变(IX作为偏移量)，形式地址A不变(作为基地址)
        
      9.相对寻址
      
        程序计数器PC加上形式地址A，即EA=(PC)+A，其中A是相对PC所指地址的位移量，可正可负，补码表示
        
      10.堆栈寻址
      
        操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址
    
      
   
